#summary Descrizione sommaria di come funziona Wviola

= Architettura generale =

Nota terminologica: visto che si possono archiviare diversi tipi di elementi (video, immagini, collezioni di immagini, registrazioni audio), qui di seguito userò il termine generico _asset_ per riferirmi ad una di queste risorse. (Nella traduzione dell'interfaccia uso il termine "Documento multimediale").

Wviola si basa su tre componenti:

  * un'applicazione di frontend (destinata agli utenti ordinari, che devono poter classificare gli asset)
  * un'applicazione di backend (destinata agli amministratori, che possono consultare i _log_, impostare valori di default nelle tabelle principali, ecc.)
  * una serie di _task_ eseguibili da riga di comando, tipicamente tramite _cron jobs_. 

Per chi è interessato,  è disponibile un [PropelSchema diagramma dello schema relazionale del DB].

I dettagli sull'uso delle applicazioni saranno progressivamente resi disponibili nella pagina relativa all'[API Application Program Interface].

== Applicazione di frontend ==

*Nota: ciò che segue va rivisto, in seguito alla considerazione che sia più efficiente
gestire dei raccoglitori di asset, con informazioni cumulative*

Descriviamo l'applicazione di frontend tramite alcuni scenari:

=== Archiviazione e classificazione di un asset ===

Matthew deve archiviare un asset (es. un video frutto di riprese con videocamera, o un file zip contenente una serie di fotografie). Mette il file in una particolare directory (o in una sottodirectory di questa) che gli è stata indicata.

Accede all'applicazione Wviola con il proprio browser, effettua il login, sceglie l'opzione "Archiviazione asset" e gli appare un elenco dei file presenti nella directory indicata, tra i quali saranno presenti anche quello da lui appena caricato.

Per ogni file trova l'indicazione del nome originale, la data di caricamento, la dimensione, una serie di fotogrammi, ecc.

Facendo clic sul link "Archivia" gli si apre una finestra in cui gli viene chiesto di specificare alcuni dati utili per la ricerca dell'asset in fasi successive (da definire nei dettagli). Quando fa clic sul pulsante "Archivia" le informazioni vengono inserite nel database e l'asset viene posto in coda per l'operazione di archiviazione.

Un asset viene inserito in un raccoglitore (_binder_) collegato all'utente: è nel raccoglitore che potranno essere inserite informazioni quali categoria, data dell'evento, ecc.

Per quanto riguarda le fotografie, Matthew sa che tutte le fotografie di cui è proprietario poste nella stessa directory verranno automaticamente trasformate in un album fotografico, che verrà archiviato come un unico asset.

=== Ricerca e visualizzazione di un asset ===

John deve visualizzare alcuni asset tra quelli precedentemente archiviati.

Accede all'applicazione Wviola con il proprio browser, effettua il login, sceglie l'opzione "Ricerca asset" e gli appare una finestra di ricerca in cui può specificare diversi criteri di ricerca (data, parola chiave, archiviatore, ecc.). Quando fa clic su "Trova" gli compare un elenco di asset che corrispondono ai criteri di ricerca indicati.

Per ogni asset è presente una piccola anteprima (un fotogramma di un video, un'immagine rimpicciolita di una collezione, ecc.). Facendo clic sul link "Visualizza" gli viene mostrato l'asset (a bassa risoluzione), nonché un link per rintracciare l'asset archiviato ad alta risoluzione.

Le operazioni di visualizzazione vengono registrate in un'apposita tabella della base di dati.

=== Modifica informazioni errate per gli asset archiviati ===

Quando un asset viene visualizzato da un utente con permessi di amministrazione, egli troverà anche il link "Modifica informazioni", per la modifica delle informazioni associate ad un asset.

== Applicazione di backend ==

Andreas è l'amministratore del sistema.

=== Visualizzazione dei log ===

Andreas consulta i log di tutte le operazioni.

=== Visualizzazione dell'archivio immagini ISO ===

Andreas consulta l'archivio delle immagini ISO dei DVD-ROM contenenti gli asset in forma non compressa.

== Applicazioni batch (task)==

Le applicazioni batch (_task_, nella terminologia di Symfony) vengono eseguite da riga di comando direttamente o tramite apposito _cron job_.

Per tutti i task è possibile ottenere un help in linea con il comando `symfony help`. Ad esempio:

{{{
$ symfony help wviola:scan-sources
Usage:
 symfony wviola:scan-sources [--application="..."] [--env="..."] [--connection="..."] [--subdir[="..."]] [--recursive[="..."]] [--logged[="..."]] 

Options:
 --application            The application name (default: frontend)
 --env                    The environment (default: dev)
 --connection             The connection name (default: propel)
 --subdir                 Subdirectory name (default: /)
 --recursive              whether recursion will be applied (default: false)
 --logged                 whether the execution will be logged in the DB (default: true)

Description:
 The wviola:scan-sources task scans the source asset directory in order to find useful information and prepare thumbnails.
 Call it with:
 
   php symfony wviola:scan-sources
 
 The subdirectory name can be specified either as '/foo', 'foo/', 'foo' or '/foo/'.
 Anyway, it must exist and must be under the path specified in wviola.yml for sources.
 
 The task ends with an exception if something goes wrong (e.g. when a file could not be
 read or written). 
}}}

Di ogni esecuzione di task viene tenuta traccia nel database, a meno che non si specifichi l'opzione `--logged=false`.

È opportuno che i task non vengano eseguiti in accavallamento. Ad esempio, l'esecuzione del task di predisposizione delle miniature potrebbe impiegare in alcuni casi 45 minuti (ovviamente dipende dal numero di file), e se viene lanciato da _cron_ ogni 30 minuti, un'esecuzione si accavallerebbe con un'altra. Per ora la gestione di eventuali meccanismi 	di lock è affidata all'amministratore di sistema.

Un'implementazione possibile è data da questo script della shell, che viene lanciato da _cron_ e che richiama un task:

{{{
#!/bin/sh

# simple lock
if [ -f "/tmp/wviola.cron.hourly.lock" ]; then
	wvpid=$(cat /tmp/wviola.cron.hourly.lock)
	if [ -d "/proc/$wvpid" ]; then
		exit 0
	else
		rm -f "/tmp/wviola.cron.hourly.lock"
	fi
fi
echo $$ > /tmp/wviola.cron.hourly.lock

# before scanning sources, it is a good idea to sync LDAP users:
/usr/local/bin/symfony wviola:sync-users --application=frontend --env=prod > /dev/null

# now I will scan the sources
/usr/local/bin/symfony wviola:scan-sources --application=frontend --env=prod --recursive=true > /dev/null

# everything fine, I can remove the lock
rm -f "/tmp/wviola.cron.hourly.lock"
exit 0
}}}

=== Sincronizzazione utenti ===

Gli utenti di Wviola vengono autenticati tramite LDAP, ma le informazioni di base su di essi devono essere inserite nel database. Sarà quindi necessario un task di sincronizzazione degli utenti, con il quale le informazioni sugli utenti nuovi vengono memorizzati nelle tabelle corrette del DB.

Il task dovrebbe essere richiamabile con il comando:

{{{
symfony wviola:sync-users --application=frontend --env=prod
}}}

Affinché la sincronizzazione avvenga correttamente, è necessario specificare nel file _config/app.yml_:

  * le unità organizzative a cui appartengono utenti e gruppi
  * quali attributi devono essere usati per utenti e gruppi (e come farli corrispondere ai campi nella base di dati)
  * quali gruppi LDAP devono essere fatti corrispondere ai GuardGroups dell'applicazione (ai quali, a loro volta, sono assegnati i permessi necessari per eseguire le diverse azioni)
  
Ad esempio, se il file _config/app.yml_ contiene le seguenti righe

{{{
  ...
  
  authentication:
    ldap_host: ldaps://ldap.example.com ldaps://ldap2.example.com
    ldap_domain: dc=example,dc=com
    ldap_users: ou=People
    ldap_groups: ou=Group
    ldap_userattribute_username: uid
    ldap_userattribute_email: mail
    ldap_userattribute_firstname: first
    ldap_userattribute_lastname: last
    ldap_groupattribute_cn: cn
    ldap_groupattribute_members: memberuid
    guardgroup_admin: [webadmin]
    guardgroup_asset_encoders: [alpha]
    guardgroup_asset_viewers: [beta,gamma]
}}}

tutti gli utenti che fanno parte del gruppo beta o del gruppo gamma verranno inseriti nel GuardGroup _asset\_viewers_, per cui potranno accedere alla visualizzazione degli asset.

L'output del task, simile al seguente,

{{{
>> group*    admin
>>  ldap*    webadmin
>> group*    asset_encoders
>>  ldap*    alpha
>> group*    asset_viewers
>>  ldap*    beta
>>  ldap*    gamma
>> user      mark
>> user      matthew
>>  group-   asset_encoders
>> user      andreas
>>  group-   asset_encoders
>> user      eloise
>>  group-   asset_viewers
>> user      john
>>  group+   asset_viewers
>> user+     sarah
>>  group+   admin
>>  group+   asset_viewers
>> user-     paul
}}}

va interpretato in questo modo:

  * sono stati presi in considerazione i GuardGroup _admin_, _asset\_encoders_ e _asset\_viewers_ (per ognuno vengono visualizzati i gruppi LDAP corrispondenti)
  * per _mark_ non ci sono state modifiche
  * _matthew_ e _andreas_ sono stati tolto dal GuardGroup _asset\_encoders_
  * _eloise_ è stata tolta dal GuardGroup _asset\_viewers_
  * _john_ è stato inserito nel GuardGroup _asset\_viewers_
  * è stato aggiunto un nuovo utente, _sarah_, inserita nei GuardGroup _admin_ e _asset\_viewers_
  * è stato reso "non più attivo" l'utente _paul_

=== Predisposizione miniature ===

Questa applicazione, per ogni file posto nella directory delle sorgenti, determina se si tratta di un asset da archiviare (ossia, se è un video, una registrazione video o una collezione di immagini).

Le collezioni di immagini vengono automaticamente create (come file zip) in base al principio che tutti i file di tipo immagine appartenenti allo stesso utente e poste nella stessa directory costituiscono una collezione. I file che confluiscono in una collezione vengono automaticamente rimossi.

Per gli asset da archiviare, il task:

  * predispone alcune immagini tra cui sceglierne una che figurerà come miniatura (estraendo fotogrammi a campione)
  * calcola un hash del file
  * archivia le informazioni associate al file in un file YAML

Le informazioni estratte vengono messe in una directory nascosta _.wviola_ presente nella directory in cui è presente l'asset (in questo modo non cambiano se il nome della directory viene variato) e sono associate all'i-node del file (così anche il nome del file può cambiare).

La ricerca avviene basandosi sulla data di ultima modifica (partendo dalla conclusione dell'ultima esecuzione dello stesso task).

Il task dovrebbe essere richiamabile con il comando:

{{{
symfony wviola:scan-sources --application=frontend --env=prod
}}}

È possibile specificare:

  * una sottodirectory in cui lavorare (che deve essere all'interno della directory di base)
  * se attivare o meno la ricorsione
  * un valore limite per la dimensione del file oltre il quale non deve essere calcolato l'hash MD5
  * se registrare nel log su DB l'esecuzione del task

Un esempio di interazione è il seguente:

{{{
$ symfony wviola:scan-sources --recursive=true --subdir=videos/stuff 
>> directory /var/wviola/data/filesystem/sources/videos/stuff
>> subdir    /videos/stuff
>> recursive true
>> logged    true

>> source    Opening candidate source file...
>> file      /var/wviola/data/filesystem/sour...os/stuff/bigbuckbunny01_copy.avi
>> info      Locked.

>> source    Opening candidate source file...
>> file      /var/wviola/data/filesystem/sources/videos/stuff/data.file
>> info      Gathering information...
>> md5sum    Computing MD5 hash...
>> info      Writing information file...
>> file+     /var/wviola/data/filesystem/sour.../videos/stuff/.wviola/394315.yml

>> source    Opening candidate source file...
>> file      /var/wviola/data/filesystem/sources/videos/stuff/sample.txt
>> info      Skipped for file name matching.

}}}

=== Preparazione degli script per l'archiviazione ===

Gli script bash che consentono di pubblicare gli asset vengono generati in base al contenuto del file _wviola.yml_. In particolare, nella sezione _publishing_ di tale file sono specificati i comandi esterni da impartire per produrre i filmati a bassa e ad alta qualità, e le immagini degli album.

Ad esempio:

{{{
publishing:
  video_width: 320
  video_height: 240
  video_low_quality_command: ffmpeg -i "%source%" -ar 22050 -ab 32000 -f flv -s %width%x%height% "%target%"
  video_high_quality_command: ffmpeg -i "%source%' -f ogg "%target%"
}}}

Il task dovrebbe essere richiamabile con il comando:

{{{
symfony wviola:generate-scripts --application=frontend --env=prod
}}}

I file generati vengono messi nella directory specificata nel file di configurazione _wviola.yml_. 

*Attenzione!* È importante rigenerare gli script se si cambiano le configurazioni (es. dove sono file e directory).

=== Pubblicazione ===

Quando un utente archivia un asset, esso viene spostato in una diversa directory, con l'attribuzione di un ID univoco (uniqid).

Questa applicazione batch, per ogni asset da archiviare:

  * effettua la codifica in bassa risoluzione
  * rende disponibile l'asset per la fruizione
  * sposta l'asset ad alta risoluzione in una directory destinata all'archiviazione off-line

Il task dovrebbe essere richiamabile con il comando:

{{{
symfony wviola:publish-assets --application=frontend --env=prod
}}}

=== Archiviazione file ad alta qualità ===

Questo task:
  * chiude i raccoglitori aperti da più di un certo numero di giorni (specificato in _wviola.yml_)
  * crea, seguendo un ordine cronologico, un'immagine ISO contenente le versioni ad alta qualità degli asset da archiviare, raggruppati per raccoglitore.

Se non ci sono abbastanza asset per riempire un DVD-ROM, esce senza fare nulla. Altrimenti, crea l'immagine ISO (in cui è presente anche un file index.html contenente informazioni sintetiche sugli asset archiviati) e imposta per il raccoglitore l'id dell'immagine ISO generata.

Il file index.html viene generato in base ad un template specificato nel file _wviola.yml_, che può essere personalizzato.

Il task dovrebbe essere richiamabile con il comando:

{{{
symfony wviola:archive-binders --application=frontend --env=prod
}}}

È possibile, se lo si desidera, definire quale comando eseguire sull'immagine ISO generata, prima che si proceda oltre. Ciò può essere utile per, ad esempio, aggiungere all'immagine ISO informazioni utili per il recupero (con il programma _dvdisaster_).

=== Archiviazione file a bassa qualità ===

Questo task:
  * crea, seguendo un ordine cronologico, un'immagine ISO contenente le versioni a bassa  risoluzione degli asset (e le relative miniature)
  * contrassegna gli asset considerati come "messi in sicurezza"

Scopo del task è di fornire un modo per fare copie di backup degli asset codificati a bassa risoluzione. È possibile richiamare il task con il comando:

{{{
symfony wviola:backup-assets --application=frontend --env=prod
}}}

Se si desidera ottenere solo un elenco dei file di cui non è ancora stata fatta una copia su DVD-ROM, si può richiamare il task con l'opzione `--list-only=true` (i file di cui non è ancora stata fatta una copia di backup su DVD-ROM dovrebbero essere messi in sicurezza in altro modo, ad esempio tramite _rsync_).

È possibile, se lo si desidera, definire quale comando eseguire sull'immagine ISO generata, prima che si proceda oltre. Ciò può essere utile per, ad esempio, aggiungere all'immagine ISO informazioni utili per il recupero (con il programma _dvdisaster_).

=== Lista dei documenti multimediali ===

Questo task elenca in forma tabellare i dati degli asset, una riga per ogni asset, con i campi separati da un tabulatore (ma è possibile specificare un diverso delimitatore in _wviola.yml_).

L'output di questo task è utilizzabile per elaborazioni personalizzate (ad esempio, predisposizione di statistiche) con altri strumenti.

È possibile richiamare il task con il comando:

{{{
symfony wviola:list-assets --application=frontend --env=prod
}}}

=== Lista dei raccoglitori ===

Questo task elenca in forma tabellare i dati relativi ai documenti multimediali, una riga per ognuno di essi, con i campi separati da un tabulatore (ma è possibile specificare un diverso delimitatore in _wviola.yml_).

L'output di questo task è utilizzabile per elaborazioni personalizzate (ad esempio, predisposizione di statistiche) con altri strumenti.

È possibile richiamare il task con il comando:

{{{
symfony wviola:list-assets --application=frontend --env=prod
}}}

=== Ricostruzione degli indici ===

La ricerca dei documenti multimediali avviene sfruttando un indicizzatore chiamato _Lucene_.

I documenti vengono automaticamente indicizzati ogni volta che vengono modificati i relativi dati nel database. Può capitare però che sia necessario rigenerare gli indici di _Lucene_ (ad esempio, dopo un ripristino del database).

Per procedere:

* eliminare completamente la directory `asset_prod_index`, presente nella directory specificata nel file _wviola.yml_, alla voce `directory_lucene_index`
* lanciare il task (vedi sotto)
* assicurarsi che per la directory generata il server web abbia permessi di lettura, scrittura ed esecuzione

Il task va richiamato con il comando:

{{{
symfony wviola:rebuild-lucene-index --application=frontend --env=prod
}}}


